#![forbid(unsafe_code)]
#![recursion_limit = "128"]

/*!
    Partial Init Derive
    ---
    This crate allows for easy, safe, ergonomic, and panic-free handling of partial 
    initialization by providing a zero-cost abstraction for the builder pattern. Handling a 
    no_std enviornment just as well as a std enviornment. This crate also takes steps to 
    make informative error messages for the users your types!

    ## Sem-ver changes

    **VERY IMPORTANT READ AND UNDERSTAND THROUGLY**

    This applies to any type marked by `#[derive(PartialInit)]`

    * Adding or removing fields (regardless of visibility) is a **major** breaking change
    * Reordering fields (regardless of visibility) is a *minor* breaking change.
        * *Note* this is a balance, users of `PartialInit` would like stability of
            the `Partial*` types, but the author would like the be able to reorder
            fields for a more readable layout
        * To mitigate the effects of this, use type aliases to refer to `Partial*` types
            that way, there is only one place in where it needs to change if the author
            decides to reorder fields
    * Changing the name of a field (regardless of visibility) is a **major** breaking change 
        * unless the old function name is maintained with the `#[func_name]` attribute.

    **note** \
    The visibility of all types created by this crate is the same as the type it is 
    derived for. This means all of the types of your fields are in the same 
    visibility as your type. For example, if you apply this derive macro to struct `A`, then
    all types created by this macro will have a `pub(crate)` visibility.

    ```rust
    #[derive(PartialInit)]
    pub(crate) struct A {
        field: i32,
        other: String
    }
    ```

    ## Usage

    Canonical example (this example will be used to explain things in this 
    documentation):
    ```rust
    #[derive(PartialInit)]
    pub struct Spell<'a, E: Effect + ?Sized> {
        with_name: String,
        damage: u32,
        range: u32,
        effects: Vec<&'a E>,
    }

    trait Effect {  }
    impl Effect for str { }
    impl<'a, E: Effect + ?Sized> Effect for Spell<'a, E> { }

    mod defaults {
        pub fn range() -> u32 { 10 }
    }
    ```

    This crate introduces the `PartialInit` derive macro. This macro creates a module 
    and a bunch of types and impls that define how the you build your type. The most 
    important of these types is `Partial{name}` (where `{name}` is the name of the 
    struct), this type holds the current state of the build, and is used to verify the 
    build process, to make sure that everything is initialized. In the example, the 
    corresponding `Parital{name}` for `Spell` is `PartialSpell`. The module is named 
    `__{name}__` and holds data about your type, such as what fields it has and some 
    type aliases. I will give a more in depth explanation later. Now onwards on how to 
    use this crate!

    After you have marked your struct with `#[PartialInit]`, you can then use it like 
    so.

    ```rust
    let spell: Spell<_> = 
        Spell::uninit()
            .with_name("Fireball".to_owned())
            .damage(20)
            .range(50)
            .effects(vec!["burning", "heat stroke"])
            .build();
    ```

    But this is boring, so I created a macro called `init`, which lives in 
    `partial-init-core`. This macro brings back the tradional struct initialization 
    for anything that implements `PartialInit`.

    ```rust
    let spell: Spell<_> = init! {
        Spell {
            with_name: "Fireball".to_owned(),
            damage: 20,
            range: 50,
            effects: vec!["burning", "heat stroke"]
        }
    }
    ```

    This macro desugars to the boring builder pattern.

    ## Attributes

    Now say we want to change up the field `with_name` to `name` for clarity in some 
    other part of code, but we don't want to make a breaking change, by changing the 
    public function `name`, which is generated by this macro. Well then you can use 
    the `#[func_name]` attribute for fields!

    ```rust
    #[derive(PartialInit)]
    pub struct Spell<'a, E: Effect + ?Sized> {
        #[func_name(with_name)]
        name: String,
        damage: u32,
        range: u32,
        effects: Vec<&'a E>,
    }
    ```

    This will keep the name of the function the same, but the internal variable name 
    won't change! Hooray!!! But now we are lazy, and we don't always have effects for 
    our spells, so we want a default, an empty `Vec`. We can tweak the code and get 
    this:

    ```rust
    #[derive(PartialInit)]
    pub struct Spell<'a, E: Effect + ?Sized> {
        #[func_name(with_name)]
        name: String,
        damage: u32,
        range: u32,

        #[default]
        effects: Vec<&'a E>,
    }
    ```

    Now we don't have to specify effects, and if we don't we get use 
    `Default::default` to get a default value.

    But what if we need a default that is different from `Default::default` or if 
    `Default` isn't implemented. Then we can use a function to specify a default.


    ```rust
    #[derive(PartialInit)]
    pub struct Spell<'a, E: Effect + ?Sized> {
        #[func_name(with_name)]
        name: String,

        damage: u32,

        #[default(defaults::range)]
        range: u32,

        #[default]
        effects: Vec<&'a E>,
    }
    ```

    Finally what if we want to deinitialize a field, for whatever reason, we can then 
    add the `#[deinit]` to the struct, and that will allow us to deinialize any field 
    we want. Or we can add `#[deinit]` just to the fields we want to be able to 
    deinitialize. Note that `#[deinit]` on the struct takes precedence on `#[deinit]` 
    on the fields.

    ```rust
    #[derive(PartialInit)]
    #[deinit]
    pub struct Spell<'a, E: Effect + ?Sized> {
        #[func_name(with_name)]
        name: String,

        damage: u32,

        #[default(defaults::range)]
        range: u32,

        #[default]
        effects: Vec<&'a E>,
    }
    ```

    And now we have all the parts! Yay. This final one can be used like so (using the 
    boring way):

    ```rust
    let spell: Spell<_> = 
        Spell::uninit()
            .with_name("Fireball".to_owned())
            .damage(20)
            .build();

    let spell: Spell<_> = 
        Spell::uninit()
            .with_name("Fireball".to_owned())
            .damage(20)
            .effects(vec!["burning", "heat stroke"])
            .build();

    let spell: Spell<_> = 
        Spell::uninit()
            .with_name("Fireball".to_owned())
            .damage(20)
            .range(50)
            .build();
    let spell: Spell<_> = 
        Spell::uninit()
            .with_name()
            .damage(20)
            .range(50)
            .deinit_with_name()
            .with_name("Fireball".to_owned())
            .build();
    ```


    Notice that we didn't have to change the `with_name` function at all in the user 
    code.

    In summurt of the attributes:

    `#[func_name]` 

    Lets you rename the function name, so you can change the internal name freely.

    `#[default]`

    Lets you use the `Default` trait to provide a default value.

    `#[default(function_path)]`

    Lets you use a function to provide a default value.

    `#[deinit]`

    Lets you deinitialize fields

    ## Reading error messages

    Let's say I forgot to initialize damage, like so

    ```rust
    let spell = Spell::uninit()
                    .with_name("Fireball".to_owned())
                    .range(50)
                    .effects(vec!["burning"])
                    .build();
    ```

    Then I will get the following error message

    ```
    error[E0599]: no method named `build` found for type `PartialSpell<'_, str, &str, 
    partial_init_core::Uninit<__Spell__::damage, u32>, u32, std::vec::Vec<&str>>` in 
    the current scope
    --> src\main.rs:135:24
        |
    107 | #[derive(PartialInit)]
        |                    - method `build` not found for this
    ...
    135 |                       .build();
        |                        ^^^^^
        |
        = note: the method `build` exists but the following trait bounds were not 
        satisfied:
                `partial_init_core::Uninit<__Spell__::damage, u32> : 
                partial_init_core::Init<__Spell__::damage, u32>`
    ```

    If you see the note at the bottom , we see that 
    `partial_init_core::Uninit<__Spell__::damage, u32> : partial_init_core::Init<__Spell__::damage, u32>`
    was not satsified. What this means is that we forgot to initialize `damage`, to an 
    `u32`. The error message spells it out for us. Yay for hijacking the type system 
    to get good error messages!

    Now what if we accidentily give damage a `i32` instead of the `u32` it is looking 
    for. Then we get:

    ```
    error[E0277]: the trait bound `i32: partial_init_core::Init<__Spell__::damage, 
    u32>` is not satisfied
    --> src\main.rs:132:24
        |
    132 |                       .damage(20i32)
        |                        ^^^^^^ the trait 
        `partial_init_core::Init<__Spell__::damage, u32>` is not implemented for `i32`
    ```

    Which says `'partial_init_core::Init<__Spell__::damage, u32>' is not implemented for 'i32'`
    meaning we can't initialize a `u32` with a `i32`.

    ## A deep dive into the inner workings

    This is all of the code (with documentation stripped for brevity) that is 
    generated by this macro for the final `Spell` struct. This section will be a 
    walkthrough on how it works and why it was created.

    Seeing this, we can see the biggest downside to this crate, the longer build 
    times. But with longer build times you get better error messages and safer, faster 
    code.

    ```rust
    #[allow(non_camel_case_types)]
    pub mod __Spell__ {
        pub enum with_name {}
        impl ::partial_init_core::FieldName for with_name {}
        pub enum damage {}
        impl ::partial_init_core::FieldName for damage {}
        pub enum range {}
        impl ::partial_init_core::FieldName for range {}
        pub enum effects {}
        impl ::partial_init_core::FieldName for effects {}
        pub mod uninit {
            use super::super::*;
            pub type with_name = ::partial_init_core::Uninit<super::with_name, String>;
            pub type damage = ::partial_init_core::Uninit<super::damage, u32>;
            pub type range = ::partial_init_core::Uninit<super::range, u32>;
            pub type effects<'a, E> = ::partial_init_core::Uninit<super::effects, Vec<&'a E>>;
        }
    }
    #[allow(non_camel_case_types)]
    #[derive(Clone, Copy)]
    pub struct PartialSpell<
        'a,
        E: Effect + ?Sized,
        with_name: ::partial_init_core::MaybeInit<__Spell__::with_name, String>,
        damage: ::partial_init_core::MaybeInit<__Spell__::damage, u32>,
        range: ::partial_init_core::MaybeInit<__Spell__::range, u32>,
        effects: ::partial_init_core::MaybeInit<__Spell__::effects, Vec<&'a E>>,
    > {
        with_name: with_name,
        damage: damage,
        range: range,
        effects: effects,
        __phantom_data__partial_init_: ::partial_init_core::PhantomData<(String, u32, u32, Vec<&'a E>)>,
    }
    #[allow(non_camel_case_types)]
    impl<'a, E: Effect + ?Sized> ::partial_init_core::PartialInit for Spell<'a, E> {
        type Uninitialized = PartialSpell<
            'a,
            E,
            ::partial_init_core::Uninit<__Spell__::with_name, String>,
            ::partial_init_core::Uninit<__Spell__::damage, u32>,
            ::partial_init_core::Uninit<__Spell__::range, u32>,
            ::partial_init_core::Uninit<__Spell__::effects, Vec<&'a E>>,
        >;
        #[inline(always)]
        fn uninit() -> Self::Uninitialized {
            Default::default()
        }
    }
    impl<'a, E: Effect + ?Sized> Default
        for PartialSpell<
            'a,
            E,
            ::partial_init_core::Uninit<__Spell__::with_name, String>,
            ::partial_init_core::Uninit<__Spell__::damage, u32>,
            ::partial_init_core::Uninit<__Spell__::range, u32>,
            ::partial_init_core::Uninit<__Spell__::effects, Vec<&'a E>>,
        >
    {
        #[inline(always)]
        fn default() -> Self {
            PartialSpell {
                __phantom_data__partial_init_: Default::default(),
                with_name: Default::default(),
                damage: Default::default(),
                range: Default::default(),
                effects: Default::default(),
            }
        }
    }
    #[allow(non_camel_case_types)]
    impl<
            'a,
            E: Effect + ?Sized,
            with_name: ::partial_init_core::Init<__Spell__::with_name, String>,
            damage: ::partial_init_core::Init<__Spell__::damage, u32>,
            range: ::partial_init_core::MaybeInit<__Spell__::range, u32>,
            effects: ::partial_init_core::MaybeInit<__Spell__::effects, Vec<&'a E>>,
        > PartialSpell<'a, E, with_name, damage, range, effects>
    {
        #[inline(always)]
        pub fn build(self) -> Spell<'a, E> {
            Spell {
                name: ::partial_init_core::Init::get(self.with_name),
                damage: ::partial_init_core::Init::get(self.damage),
                range: ::partial_init_core::MaybeInit::get(self.range).unwrap_or_else(defaults::range),
                effects: ::partial_init_core::MaybeInit::get(self.effects).unwrap_or_default(),
            }
        }
    }
    #[allow(non_camel_case_types)]
    impl<
            'a,
            E: Effect + ?Sized,
            damage: ::partial_init_core::MaybeInit<__Spell__::damage, u32>,
            range: ::partial_init_core::MaybeInit<__Spell__::range, u32>,
            effects: ::partial_init_core::MaybeInit<__Spell__::effects, Vec<&'a E>>,
        >
        PartialSpell<
            'a,
            E,
            ::partial_init_core::Uninit<__Spell__::with_name, String>,
            damage,
            range,
            effects,
        >
    {
        #[inline(always)]
        pub fn with_name<with_name: ::partial_init_core::Init<__Spell__::with_name, String>>(
            self,
            with_name: with_name,
        ) -> PartialSpell<'a, E, with_name, damage, range, effects> {
            PartialSpell {
                __phantom_data__partial_init_: Default::default(),
                with_name,
                damage: self.damage,
                range: self.range,
                effects: self.effects,
            }
        }
    }
    #[allow(non_camel_case_types)]
    impl<
            'a,
            E: Effect + ?Sized,
            with_name: ::partial_init_core::MaybeInit<__Spell__::with_name, String>,
            range: ::partial_init_core::MaybeInit<__Spell__::range, u32>,
            effects: ::partial_init_core::MaybeInit<__Spell__::effects, Vec<&'a E>>,
        >
        PartialSpell<
            'a,
            E,
            with_name,
            ::partial_init_core::Uninit<__Spell__::damage, u32>,
            range,
            effects,
        >
    {
        #[inline(always)]
        pub fn damage<damage: ::partial_init_core::Init<__Spell__::damage, u32>>(
            self,
            damage: damage,
        ) -> PartialSpell<'a, E, with_name, damage, range, effects> {
            PartialSpell {
                __phantom_data__partial_init_: Default::default(),
                with_name: self.with_name,
                damage,
                range: self.range,
                effects: self.effects,
            }
        }
    }
    #[allow(non_camel_case_types)]
    impl<
            'a,
            E: Effect + ?Sized,
            with_name: ::partial_init_core::MaybeInit<__Spell__::with_name, String>,
            damage: ::partial_init_core::MaybeInit<__Spell__::damage, u32>,
            effects: ::partial_init_core::MaybeInit<__Spell__::effects, Vec<&'a E>>,
        >
        PartialSpell<
            'a,
            E,
            with_name,
            damage,
            ::partial_init_core::Uninit<__Spell__::range, u32>,
            effects,
        >
    {
        #[inline(always)]
        pub fn range<range: ::partial_init_core::Init<__Spell__::range, u32>>(
            self,
            range: range,
        ) -> PartialSpell<'a, E, with_name, damage, range, effects> {
            PartialSpell {
                __phantom_data__partial_init_: Default::default(),
                with_name: self.with_name,
                damage: self.damage,
                range,
                effects: self.effects,
            }
        }
    }
    #[allow(non_camel_case_types)]
    impl<
            'a,
            E: Effect + ?Sized,
            with_name: ::partial_init_core::MaybeInit<__Spell__::with_name, String>,
            damage: ::partial_init_core::MaybeInit<__Spell__::damage, u32>,
            range: ::partial_init_core::MaybeInit<__Spell__::range, u32>,
        >
        PartialSpell<
            'a,
            E,
            with_name,
            damage,
            range,
            ::partial_init_core::Uninit<__Spell__::effects, Vec<&'a E>>,
        >
    {
        #[inline(always)]
        pub fn effects<effects: ::partial_init_core::Init<__Spell__::effects, Vec<&'a E>>>(
            self,
            effects: effects,
        ) -> PartialSpell<'a, E, with_name, damage, range, effects> {
            PartialSpell {
                __phantom_data__partial_init_: Default::default(),
                with_name: self.with_name,
                damage: self.damage,
                range: self.range,
                effects,
            }
        }
    }
    #[allow(non_camel_case_types)]
    impl<
            'a,
            E: Effect + ?Sized,
            with_name: ::partial_init_core::MaybeInit<__Spell__::with_name, String>,
            damage: ::partial_init_core::MaybeInit<__Spell__::damage, u32>,
            range: ::partial_init_core::MaybeInit<__Spell__::range, u32>,
            effects: ::partial_init_core::MaybeInit<__Spell__::effects, Vec<&'a E>>,
        > PartialSpell<'a, E, with_name, damage, range, effects>
    {
        #[inline(always)]
        pub fn deinit_with_name(self)
        -> PartialSpell<
            'a,
            E,
            ::partial_init_core::Uninit<__Spell__::with_name, String>,
            damage,
            range,
            effects,
        > {
            PartialSpell {
                __phantom_data__partial_init_: Default::default(),
                with_name: Default::default(),
                damage: self.damage,
                range: self.range,
                effects: self.effects,
            }
        }
        #[inline(always)]
        pub fn deinit_damage(self)
        -> PartialSpell<
            'a,
            E,
            with_name,
            ::partial_init_core::Uninit<__Spell__::damage, u32>,
            range,
            effects,
        > {
            PartialSpell {
                __phantom_data__partial_init_: Default::default(),
                with_name: self.with_name,
                damage: Default::default(),
                range: self.range,
                effects: self.effects,
            }
        }
        #[inline(always)]
        pub fn deinit_range(self)
        -> PartialSpell<
            'a,
            E,
            with_name,
            damage,
            ::partial_init_core::Uninit<__Spell__::range, u32>,
            effects,
        > {
            PartialSpell {
                __phantom_data__partial_init_: Default::default(),
                with_name: self.with_name,
                damage: self.damage,
                range: Default::default(),
                effects: self.effects,
            }
        }
        #[inline(always)]
        pub fn deinit_effects(self)
        -> PartialSpell<
            'a,
            E,
            with_name,
            damage,
            range,
            ::partial_init_core::Uninit<__Spell__::effects, Vec<&'a E>>,
        > {
            PartialSpell {
                __phantom_data__partial_init_: Default::default(),
                with_name: self.with_name,
                damage: self.damage,
                range: self.range,
                effects: Default::default(),
            }
        }
    }
    ```

    ---

    But before we dive into the inner workings, we need to understand the 
    `partial-init-core` crate, so please read the documentation for that here. I will 
    not be explaining the traits in `partial-init-core` here.

    ---

    The first thing that is created the module `__Spell__`. This module contains lots 
    of information used in error messages. Each of the enums corrosponds to a 
    field-initializing-function ( FIF ), and is used to name the FIF in error 
    messages. It also holds the `uninit` module, which holds type aliases for 
    `partial_init_core::Uninit` for all of the fields on the struct. The `uninit` 
    module is helpful for creating your own functions on `Partial{name}` types.

    ---

    Next we create the `PartialSpell` type, which I will copy here, for easy reference.

    ```rust
    #[allow(non_camel_case_types)]
    pub struct PartialSpell<
        'a, E: Effect + ?Sized,
        with_name: ::partial_init_core::MaybeInit<__Spell__::with_name, String>,
        damage: ::partial_init_core::MaybeInit<__Spell__::damage, u32>,
        range: ::partial_init_core::MaybeInit<__Spell__::range, u32>,
        effects: ::partial_init_core::MaybeInit<__Spell__::effects, Vec<&'a E>>,
    > {
        with_name: with_name,
        damage: damage,
        range: range,
        effects: effects,
        __phantom_data__partial_init_: ::partial_init_core::PhantomData<(String, u32, u32, Vec<&'a E>)>,
    }
    ```

    This is a very generic struct. Each of the fields of `Spell` is a field on 
    `PartialSpell` with it's own generic type. There is also a `PhantomData` field, 
    that is there so that I can use the generic type on `Spell` everywhere I use 
    `ParitalSpell`, and so that I can add the `::partial_init_core::MaybeInit<_, _>` 
    bound on the generic types. This bounds enforces the author to be responisble when 
    using `PartialSpell`, meaning it can always be built (not precisely true, but good 
    enough).

    One major benefit of using generics, is that it is a zero-cost abstraction. If you 
    only initialize use memory for the fields you initialize. Also, in release mode, 
    fully initializing a struct and building it turns into the same assembly as 
    initializing the struct directly. (Yay!)

    ---

    Next we see the `::partial_init_core::PartialInit` implementation, this creates 
    the uninit function on `Spell`. This allows you to create a safe uninitialized 
    `Spell`. This value can then be uninitialzed with FIFs which will be detailed 
    later.

    We also see a `Default` impl for PartialInit for completeness.

    ---

    Next we see the implementation of the `build` field.
    Seen here:
    ```rust
    #[allow(non_camel_case_types)]
    impl<
            'a, E: Effect + ?Sized,
            with_name: ::partial_init_core::Init<__Spell__::with_name, String>,
            damage: ::partial_init_core::Init<__Spell__::damage, u32>,
            range: ::partial_init_core::MaybeInit<__Spell__::range, u32>,
            effects: ::partial_init_core::MaybeInit<__Spell__::effects, Vec<&'a E>>,
        > PartialSpell<'a, E, with_name, damage, range, effects>
    {
        fn build(self) -> Spell<'a, E> {
            Spell {
                name: ::partial_init_core::Init::get(self.with_name),
                damage: ::partial_init_core::Init::get(self.damage),
                range: ::partial_init_core::MaybeInit::get(self.range).unwrap_or_else(defaults::range),
                effects: ::partial_init_core::MaybeInit::get(self.effects).unwrap_or_default(),
            }
        }
    }
    ```

    In the impl-generics we see all of the generic types, you can see that all of the 
    fields marked with `#[default]` get a `::partial_init_core::MaybeInit` bound, 
    while the rest get a `::partial_init_core::Init` bound. This reflects how default 
    values don't have to be initialized by the user, while the other fields do must be 
    initialized by the user. In the function we then fetch the value and unwrap it if 
    necessary. Note that the default is called lazily, only if the value is not 
    supplied by the user.

    ---

    Finally we get to the FIFs, there functions initialize one field of 
    `PartialSpell`. All of the other fields get passed through, while the specified 
    field gets it's value initialized. Note that the specified value must currently be 
    `::partial_init_core::Uninit`, this prevents a value from being initialzed twice.

    Along with each FIF, we can see a corrosponding `deinit_{fn_name}`, this is what 
    allows deinitialization. We simply replace the field value with an 
    `::partial_init_core::Uninit`, which signifies that is is deinitialized.

    And this concludes the guided tour, thank you for your time.

    ## Neat tips and tricks

    Because all of these implement `partial_init_core::Init<_, T>`
    * `fn() -> T`
    * `&'a dyn Fn() -> T`
    * `Arc<dyn Fn() -> T>`
    * `Rc<dyn Fn() -> T>`
    * `Box<dyn Fn() -> T>`
    * `&'a mut dyn FnMut() -> T`
    * `Box<dyn FnMut() -> T>`
    * ...

    you can lazily initialize arugments using funcitons that return type `T`.

    example:

    ```rust
    let spell_name: fn() -> _             =          || "Fireball".to_owned();
    let damage    : &mut dyn FnMut() -> _ = &mut     || 20;
    let range     : Box<dyn Fn() -> _>    = Box::new(|| 50);
    let effects   : &dyn Fn() -> _        = &        || vec!["burning"];
    let spell = Spell::uninit()
                    .with_name(spell_name)
                    .damage(damage)
                    .range(range)
                    .effects(effects)
                    .build();
    ```

    In doing so, expensive calculations can be deferred till build is called.

    ---

    Because `Option<T>: partial_init_core::MaybeInit<_, T>`, you can omit `Some`
    when using `Option`. In combination with the `#[default]`, you can get
    true optional fields.

    example:

    ```rust
    #[derive(PartialInit)]
    struct WithOption {
        #[default]
        value: Option<u32>
    }

    let spell = WithOption::uninit()
                        .value(10)
                        .build();

    let spell = WithOption::uninit()
                        .build();
    ```

    ---

    You can initialize default fields with `Option`.

    example:

    ```rust
    #[derive(PartialInit)]
    struct WithDefault {
        #[default]
        value: u32
    }

    let value = if rand_bool() { Some(10) } else { None };

    let spell = WithDefault::uninit()
                            .value(value)
                            .build();
    ```

    ---

    The init macro in partial-init-core can initialize mutiple structs at once, and produces 
    a tuple containing each of the values.

    ```rust
    let (
        spell_1,
        spell_2,
        with_option_1,
        with_option_2,
    ) = init! {
        Spell {
            with_name: "Fireball".to_owned(),
            damage: 30,
            range: 100,
            effects: vec!["burning"]
        },
        Spell {
            with_name: "Frost Touch".to_owned(),
            damage: 0,
            effects: vec!["slow", "frost"]
        },
        WithOption {},
        WithOption {
            value: 10
        }
    };
    ```
*/

extern crate proc_macro;
extern crate proc_macro2;

#[macro_use]
extern crate syn;

#[macro_use]
extern crate quote;

use self::proc_macro::TokenStream;
use syn::parse::Error;
use syn::{punctuated::Punctuated, token::Comma, Ident};

// #[default] or #[default(<path>)]
enum DefaultAttribute {
    Path(syn::Path),
    Default,
    None,
}

// Attribute handler
struct PartialInitAttribute {
    fun: Option<Ident>,
    def: DefaultAttribute,
    deinit: bool
}

impl PartialInitAttribute {
    fn new() -> Self {
        Self {
            fun: None,
            def: DefaultAttribute::None,
            deinit: false
        }
    }
}

impl Default for PartialInitAttribute {
    fn default() -> Self {
        Self::new()
    }
}

enum AttrParseError {
    NotMine,
    Error(syn::parse::Error),
}

fn quote_one<T: quote::ToTokens>(t: T) -> proc_macro2::TokenStream {
    quote! { #t, }
}

fn to_string<T: quote::ToTokens>(t: T) -> String {
    format! { "{}" , quote! { #t } }
}

type List<T> = Punctuated<T, Comma>;

#[doc(hidden)]
#[proc_macro_derive(PartialInit, attributes(deinit, func_name, default))]
pub fn partial_init_derive(input: TokenStream) -> TokenStream {
    let ast = parse_macro_input!(input as syn::DeriveInput);

    let name = ast.ident;

    let fields: List<_> = {
        const ERROR_INFO: &str = "only structs with named fields are allowed to be used in partial initialization";
        if let syn::Data::Struct(data) = ast.data {
            if let syn::Fields::Named(fields) = data.fields {
                fields.named
            } else {
                return Error::new(name.span(), ERROR_INFO).to_compile_error().into();
            }
        } else {
            return Error::new(name.span(), ERROR_INFO).to_compile_error().into();
        }
    };

    let impl_deinit = {
        let mut impl_deinit = false;

        for i in ast.attrs {
            if to_string(i.path) == "deinit" {
                impl_deinit = true;
                break;
            }
        }

        impl_deinit
    };
    
    let vis = ast.vis;
    let (impl_generics, ty_generics, where_clause) = ast.generics.split_for_impl();

    let (partial_name, internal_module) = {
        let ast_name = &name;
        let name = quote! { #ast_name };
        (
            Ident::new(&*format!("Partial{}", name), ast_name.span()),
            Ident::new(&*format!("__{}__", name), ast_name.span()),
        )
    };

    let lifetimes = {
        let mut lt: List<_> = ast
            .generics
            .lifetimes()
            .map(|x| &x.lifetime)
            .collect();
        if !lt.is_empty() {
            lt.push_punct(Token![,](name.span()));
        }
        lt
    };

    let generics = {
        let mut gen: List<_> = ast.generics.type_params().map(|x| &x.ident).collect();
        if !gen.is_empty() {
            gen.push_punct(Token![,](name.span()));
        }
        gen
    };

    let attrs: Vec<_> = match parse_attributes(&fields) {
        Ok(attrs) => attrs,
        Err(msg) => return msg.to_compile_error().into(),
    };
    
    // before #[func_name] is applied
    let old_field_names: List<_> = fields
        .iter()
        .map(|field| field.ident.as_ref().unwrap())
        .collect();

    // after #[func_name] is applied
    let field_names: List<_> = old_field_names
        .iter()
        .zip(attrs.iter())
        .map(|(old_field, attr)| attr.fun.as_ref().unwrap_or(old_field))
        .collect();
    
    // stuff to throw in the PhantomData, so we can have nice generics
    let phantom_data: List<_> = fields.iter().map(|field| &field.ty).collect();
    // fields in the struct declaration
    let struct_fields: List<_> = field_names
        .iter()
        .map(|field| quote! { #field: #field })
        .collect();

    // Generic arguements without bounds
    let generic_args = quote! { #lifetimes #generics #field_names };
    // Generic arguements with bounds
    let generic_decl = {
        let mut temp = quote! {};
        temp.extend(ast.generics.lifetimes().map(quote_one));
        temp.extend(ast.generics.type_params().map(quote_one));
        temp.extend(
            field_names
                .iter()
                .zip(fields.iter().map(|x| &x.ty))
                .map(|(x, ty)| {
                    quote! { #x: ::partial_init_core::MaybeInit<#internal_module::#x, #ty>, }
                }),
        );
        temp
    };

    // Stuff that goes on in the uninit function
    let (uninit_struct, uninit_struct_initializer) = {
        let mut uninit_struct = quote! { #lifetimes #generics };
        uninit_struct.extend(field_names.iter().zip(fields.iter().map(|x| &x.ty)).map(
            |(x, ty)| {
                quote! { ::partial_init_core::Uninit<#internal_module::#x, #ty>, }
            },
        ));

        let mut initializer = quote! { __phantom_data__partial_init_: Default::default() };
        initializer.extend(field_names.iter().map(|x| quote! { ,#x: Default::default() }));
        (uninit_struct, initializer)
    };

    // Stuff that goes on in the build function
    let (init_struct, init_struct_initializer) = {
        let mut init_struct = quote! {};
        init_struct.extend(ast.generics.lifetimes().map(quote_one));
        init_struct.extend(ast.generics.type_params().map(quote_one));
        init_struct.extend(
            field_names
                .iter()
                .zip(fields.iter().map(|field| &field.ty))
                .zip(attrs.iter())
                .map(|((field, ty), attr)| {
                    if let DefaultAttribute::None = &attr.def {
                        quote! { #field: ::partial_init_core::Init<#internal_module::#field, #ty>, }
                    } else {
                        quote! { #field: ::partial_init_core::MaybeInit<#internal_module::#field, #ty>, }
                    }
                }),
        );

        let mut initializer = quote! {};
        initializer.extend(field_names.iter().zip(attrs.iter()).zip(old_field_names.iter()).map(|((field, attr), old_field)| {
            if let DefaultAttribute::Path(def) = &attr.def {
                quote! { #old_field: ::partial_init_core::MaybeInit::get(self.#field).unwrap_or_else(#def), }
            } else if let DefaultAttribute::Default = &attr.def {
                quote! { #old_field: ::partial_init_core::MaybeInit::get(self.#field).unwrap_or_default(), }
            } else {
                quote! { #old_field: ::partial_init_core::Init::get(self.#field), }
            }
        }));

        (init_struct, initializer)
    };

    let internal_module_contents: proc_macro2::TokenStream = {
        let mut internal_module_contents = quote! {};

        internal_module_contents.extend(field_names.iter().map(|field| {
            let field_doc = format! {
                " This type represents a field on `{}`, and is not meant to be constructed.",
                quote! { #name }
            };
            quote! {
                /// This type was created by the parital-init-derive crate, see that documentation
                /// for detail on how this operation works (it's long and detailed)
                /// 
                #[doc = #field_doc]
                /// It is only used as a type-tag.
                pub enum #field {}
                impl ::partial_init_core::FieldName for #field { }
            }
        }));

        let generics = &ast.generics;
        let gen = fields
            .iter()
            .map(|field_tok| extract_generics(&field_tok.ty, &generics));

        let uninit = {
            let mut temp = quote! {};
            
            let uninit_field_doc = format! {
                " This type represents an uninitialized field on `{}`.",
                quote! { #name }
            };
            temp.extend(field_names.iter().zip(fields.iter()).zip(gen).map(
                |((field, field_tok), gen)| {
                    let ty = &field_tok.ty;
                    quote! {
                        /// This type was created by the parital-init-derive crate, see that documentation
                        /// for detail on how this operation works (it's long and detailed)
                        /// 
                        #[doc = #uninit_field_doc]
                        pub type #field<#gen> = ::partial_init_core::Uninit<super::#field, #ty>;
                    }
                },
            ));

            let uninit_mod_doc = format! {
                " This module holds types that represents an uninitialized fields on `{}`.",
                quote! { #partial_name }
            };
            quote! {
                /// This module was created by the parital-init-derive crate, see that documentation
                /// for detail on how this operation works (it's long and detailed)
                /// 
                #[doc = #uninit_mod_doc]
                pub mod uninit {
                    use super::super::*;
                    #temp
                }
            }
        };

        internal_module_contents.extend(std::iter::once(uninit));

        internal_module_contents
    };
    
    let doc_comment1 = format! {
        " This type represents a partially initialized `{name}`, each of the functions",
        name = quote! { #name }
    };
    
    let doc_comment2 = format! {
        " `{name}`. All builder api functions and FIFs will be marked as such.",
        name = quote! { #name }
    };

    let doc_comment3 = format! {
        " You can create a `{partial_name}` by calling `{name}::uninit()`, then using the relavant functions listed",
        name = quote! { #name },
        partial_name = quote! { #partial_name }
    };

    let build_doc = format! {
        " It is the final step in creating a `{name}`.",
        name = quote! { #name }
    };

    let internal_mod_doc = format! {
        " This module holds types that represent meta-data about `{}` and `{}`",
        quote! { #name }, quote! { #partial_name }
    };

    let mut expanded = quote! {
        /// This module was created by the parital-init-derive crate, see that documentation
        /// for detail on how this operation works (it's long and detailed)
        /// 
        #[doc = #internal_mod_doc]
        /// for better error messages.
        #[allow(non_camel_case_types)]
        #vis mod #internal_module {
            #internal_module_contents
        }

        /// This type was created by the parital-init-derive crate, see that documentation
        /// for detail on how this operation works (it's long and detailed)
        /// 
        #[doc = #doc_comment1]
        /// on this type is one of four things: part of the builder api,
        /// a field-initializing-function (FIF), a field-deinitializing-function (FDF), or a function defined by the author of
        #[doc = #doc_comment2]
        #[doc = #doc_comment3]
        /// below to initialize the data.
        #[allow(non_camel_case_types)]
        #[derive(Clone, Copy)]
        #vis struct #partial_name<#generic_decl>
        #where_clause {
            #struct_fields,
            __phantom_data__partial_init_: ::partial_init_core::PhantomData<(#phantom_data)>
        }

        #[allow(non_camel_case_types)]
        impl #impl_generics ::partial_init_core::PartialInit for #name #ty_generics
        #where_clause {
            type Uninitialized = #partial_name<#uninit_struct>;

            #[inline(always)]
            fn uninit() -> Self::Uninitialized {
                Default::default()
            }
        }

        impl #impl_generics Default for #partial_name<#uninit_struct>
        #where_clause {
            #[inline(always)]
            fn default() -> Self {
                #partial_name {
                    #uninit_struct_initializer
                }
            }
        }

        #[allow(non_camel_case_types)]
        impl<#init_struct> #partial_name<#generic_args>
        #where_clause {
            /// This function is part of the builder api.
            #[doc = #build_doc]
            #[inline(always)]
            #vis fn build(self) -> #name #ty_generics {
                #name {
                    #init_struct_initializer
                }
            }
        }
    };

    let mut deinit_block = quote! {};
    let has_deinit_block = {
        let (iter, has_deinit_block) = field_initializing_function_impl(
            impl_deinit,
            &mut deinit_block,

            &vis,
            &partial_name,
            &internal_module,

            &field_names,
            &fields,
            &attrs,

            &lifetimes,
            &ast.generics,
            &generics,
            &generic_args,
            &where_clause
        );
        
        expanded.extend(iter);
        has_deinit_block
    };
    
    if has_deinit_block {
        expanded.extend(std::iter::once(quote! {
            #[allow(non_camel_case_types)]
            impl <#generic_decl> #partial_name<#generic_args>
            #where_clause {
                #deinit_block
            }
        }));
    }

    // println!("{}", expanded);

    TokenStream::from(expanded)
}

fn extract_generics(ty: &syn::Type, generics: &syn::Generics) -> List<proc_macro2::TokenStream> {
    use syn::{ConstParam, GenericParam::*, LifetimeDef, TypeParam};

    let mut gen: Vec<_> = extract_generics_helper(ty, generics).collect();

    gen.sort_by(|a, b| {
        match (a, b) {
            (Type(TypeParam { ident: a, .. }), Type(TypeParam { ident: b, .. })) => {
                Ord::cmp(&a, &b)
            }
            (Const(ConstParam { ident: a, .. }), Const(ConstParam { ident: b, .. })) => {
                Ord::cmp(&a, &b)
            }
            (
                Lifetime(LifetimeDef { lifetime: a, .. }),
                Lifetime(LifetimeDef { lifetime: b, .. }),
            ) => Ord::cmp(&a.ident, &b.ident),
            (Lifetime(_), _) => std::cmp::Ordering::Less,
            (_, Lifetime(_)) => std::cmp::Ordering::Greater,
            (Type(_), _) => std::cmp::Ordering::Less,
            (_, Type(_)) => std::cmp::Ordering::Greater
        }
    });

    gen.dedup_by(|a, b| match (a, b) {
        (Type(TypeParam { ident: a, .. }), Type(TypeParam { ident: b, .. })) => a == b,
        (Const(ConstParam { ident: a, .. }), Const(ConstParam { ident: b, .. })) => a == b,
        (Lifetime(LifetimeDef { lifetime: a, .. }), Lifetime(LifetimeDef { lifetime: b, .. })) => {
            a.ident == b.ident
        }
        _ => false,
    });

    gen.into_iter()
            .map(|ty| match ty {
                syn::GenericParam::Type(syn::TypeParam { ident, .. }) => quote! { #ident },
                syn::GenericParam::Lifetime(LifetimeDef { lifetime, .. }) => quote! { #lifetime },
                syn::GenericParam::Const(_) => unimplemented!(),
            }).collect()
}

/// Super ugly, but working code
fn extract_generics_helper<'a>(
    ty: &'a syn::Type,
    generics: &'a syn::Generics,
) -> Box<dyn 'a + Iterator<Item = &'a syn::GenericParam>> {
    use syn::{Type::*, *};

    match ty {
          Slice(TypeSlice { elem, .. })
        | Array(TypeArray { elem, .. })
        | Ptr(TypePtr { elem, .. })
        | Paren(TypeParen { elem, .. })
        | Group(TypeGroup { elem, .. }) => extract_generics_helper(&elem, generics),

        Reference(TypeReference { elem, lifetime, .. }) => {
            let ty = lifetime.iter()
                             .flat_map(move |lt| handle_lifetime(lt, generics))
                             .chain(extract_generics_helper(&elem, generics));
            Box::new(ty)
        },

        Tuple(TypeTuple { elems, .. }) => 
            Box::new(elems.iter().flat_map(move |x| extract_generics_helper(x, generics))),
        
        Path(ty) => handle_path(&ty.path, generics),
        BareFn(ty) => {
            let output = if let syn::ReturnType::Type(_, ty) = &ty.output {
                Some(extract_generics_helper(&ty, generics))
            } else {
                None
            };

            let iter = ty.inputs.iter()
                                .map(move |x| extract_generics_helper(&x.ty, generics))
                                .chain(output.into_iter())
                                .flatten();

            Box::new(iter) as Box<dyn Iterator<Item = &GenericParam>>
        }
        Never(_) => Box::new(None.into_iter()),
        TraitObject(TypeTraitObject { bounds, .. }) |
        ImplTrait(TypeImplTrait { bounds, .. }) => {
            use syn::TypeParamBound::*;
            Box::new(bounds.iter().flat_map(move |x| match x {
                Trait(tr) => Some(handle_path(&tr.path, generics)),
                Lifetime(lt) => handle_lifetime(lt, generics)
                                    .map(std::iter::once)
                                    .map(Box::new)
                                    .map(|x| x as Box<dyn Iterator<Item = &GenericParam>>)
            }).flatten()) as Box<dyn Iterator<Item = &GenericParam>>
        }
        Verbatim(_) | Infer(_) | Macro(_) => unreachable!(),
    }
}

fn handle_lifetime<'a>(
    lifetime: &'a syn::Lifetime,
    generics: &'a syn::Generics,
) -> Option<&'a syn::GenericParam> {
    let pos = generics.params.iter().position(|x| {
        if let syn::GenericParam::Lifetime(lt) = x {
            &lt.lifetime == lifetime
        } else {
            false
        }
    });
    
    pos.map(move |i| &generics.params[i])
}

fn handle_path<'a>(
    path: &'a syn::Path,
    generics: &'a syn::Generics,
)
 -> Box<dyn 'a + Iterator<Item = &'a syn::GenericParam>> {
    use syn::*;

    Box::new(path.segments.iter().flat_map(move |seg| {
        let pos = generics.params.iter().position(|x| {
            if let GenericParam::Type(ty) = x {
                ty.ident == seg.ident
            } else {
                false
            }
        });

        let args = if let PathArguments::AngleBracketed(AngleBracketedGenericArguments {
            args,
            ..
        }) = &seg.arguments {
            Some(args.iter().flat_map(move |arg| match arg {
                GenericArgument::Type(ty) |
                GenericArgument::Binding(Binding { ty, .. }) =>
                    Some(extract_generics_helper(ty, generics)),
                GenericArgument::Lifetime(lt) => {
                    handle_lifetime(lt, generics)
                        .map(std::iter::once)
                        .map(Box::new)
                        .map(|x| x as Box<dyn Iterator<Item = &syn::GenericParam>>)
                },
                _ => None
            }))
        } else {
            None
        };

        args.into_iter()
            .flatten()
            .flatten()
            .chain(pos.map(|p| &generics.params[p]))
    }))
}

fn parse_attributes(fields: &List<syn::Field>) -> Result<Vec<PartialInitAttribute>, syn::parse::Error> {
    fields.iter()
    .map(move |field| {
        field.attrs
            .iter()
            .map(move |a| {
                struct AttrParser<P: syn::parse::Parse>(List<P>);

                impl<P: syn::parse::Parse> syn::parse::Parse for AttrParser<P> {
                    fn parse(
                        input: syn::parse::ParseStream,
                    ) -> Result<Self, syn::parse::Error> {
                        let mut list = List::new();

                        while !input.is_empty() {
                            let name = input.parse::<P>()?;
                            list.push(name);
                            if input.peek(Token![,]) {
                                input.parse::<Token![,]>()?;
                            } else if !input.is_empty() {
                                return Err(input.error("Invalid parse: expected comma"));
                            }
                        }

                        Ok(AttrParser(list))
                    }
                }

                let tts = &a.tts;
                let span = a.path.segments[0].ident.span();
                let path = to_string(&a.path);

                match &*path {
                    "func_name" | "default" | "deinit" => (),
                    _ => return Err(AttrParseError::NotMine),
                };

                let tts = to_string(tts);
                let tts = tts.trim();

                let inside: List<syn::Path> = if !tts.is_empty() {
                    match syn::parse_str(&tts[1..tts.len() - 1]) {
                        Ok(AttrParser(rest)) => rest,
                        Err(msg) => return Err(AttrParseError::Error(Error::new(span, msg))),
                    }
                } else {
                    List::new()
                };
                Ok((span, path, inside))
            })
            .fold(Ok(PartialInitAttribute::default()), move |attr, x| match (attr, x) {
                (Ok(mut val), Ok((span, path, mut inside))) => {
                    match &*path {
                        "func_name" => {
                            let mut path = inside.pop().unwrap().into_value();
                            if inside.pop().is_some() {
                                return Err(Error::new(
                                    span,
                                    "please only provide one function name",
                                ));
                            }

                            let segment = path.segments.pop().unwrap().into_value();
                            if path.segments.pop().is_some() {
                                return Err(Error::new(span, "expected identifier"));
                            }

                            val.fun = Some(segment.ident);
                        }
                        "default" => {
                            val.def = inside
                                .pop()
                                .map(syn::punctuated::Pair::into_value)
                                .map(DefaultAttribute::Path)
                                .unwrap_or(DefaultAttribute::Default);
                        },
                        "deinit" => {
                            if inside.pop().is_some() {
                                return Err(Error::new(
                                    span,
                                    "deinit takes no arguments",
                                ));
                            }

                            val.deinit = true;
                        }
                        _ => unreachable!(),
                    }
                    Ok(val)
                }
                (err @ Err(_), _) => err,
                (attr, Err(AttrParseError::NotMine)) => attr,
                (_, Err(AttrParseError::Error(err))) => Err(err),
            })
    }).collect()
}

// 13 arugments, oh god, the joys of extracting code
// that used to take a lot from the enviornment
fn field_initializing_function_impl<'a>(
    impl_deinit: bool,
    deinit_block: &'a mut proc_macro2::TokenStream,

    vis: &'a syn::Visibility,
    partial_name: &'a syn::Ident,
    internal_module: &'a syn::Ident,

    field_names: &'a List<&'a proc_macro2::Ident>,
    fields: &'a List<syn::Field>,
    attrs: &'a [PartialInitAttribute],

    lifetimes: &'a List<&'a syn::Lifetime>,
    ast_generics: &'a syn::Generics,
    generics: &'a List<&'a syn::Ident>,
    generic_args: &'a proc_macro2::TokenStream,
    where_clause: &'a std::option::Option<&syn::WhereClause>,
) -> (impl 'a + Iterator<Item = proc_macro2::TokenStream>, bool) {
    let mut has_deinit_block = false;

    let iter = field_names
        .iter()
        .zip(fields.iter().map(move |field| &field.ty))
        .zip(attrs.iter())
        .enumerate()
        .map(move |(i, ((field, ty), attr))| {
            let (impl_generics, old_generic_args) = {
                let mut impl_generics = quote! {};
                impl_generics.extend(ast_generics.lifetimes().map(quote_one));
                impl_generics.extend(ast_generics.type_params().map(quote_one));

                impl_generics.extend(field_names.iter()
                    .zip(fields.iter().map(|x| &x.ty))
                    .enumerate()
                    .flat_map(|(j, (field_j, ty_j))| {
                        if i == j {
                            None
                        } else {
                            Some(quote! {
                                #field_j: ::partial_init_core::MaybeInit<#internal_module::#field_j, #ty_j>,
                            })
                        }
                    }),
                );

                let mut old_generic_args = quote! { #lifetimes #generics };

                old_generic_args.extend(
                    field_names
                        .iter()
                        .zip(fields.iter().map(|x| &x.ty))
                        .enumerate()
                        .map(|(j, (field_j, ty_j))| {
                            if i == j {
                                quote! { ::partial_init_core::Uninit<#internal_module::#field_j, #ty_j>, }
                            } else {
                                quote! { #field_j, }
                            }
                        })
                );

                (impl_generics, old_generic_args)
            };

            let initializer = {
                let mut temp = quote! { __phantom_data__partial_init_: Default::default() };
                
                temp.extend(
                    field_names
                        .iter()
                        .enumerate()
                        .map(|(j, field_j)| {
                            if i == j {
                                quote! { ,#field_j }
                            } else {
                                quote! { ,#field_j: self.#field_j }
                            }
                        })
                );
                
                temp
            };

            let func_name = attr.fun.as_ref().unwrap_or(field);
            
            if impl_deinit || attr.deinit {
                has_deinit_block = true;
                let deinitializer = {
                    let mut temp = quote! { __phantom_data__partial_init_: Default::default() };
                    
                    temp.extend(
                        field_names
                            .iter()
                            .enumerate()
                            .map(|(j, field_j)| {
                                if i == j {
                                    quote! { ,#field_j: Default::default() }
                                } else {
                                    quote! { ,#field_j: self.#field_j }
                                }
                            })
                    );
                    
                    temp
                };

                let deinit_func_doc = format! {
                    " This is a FDF, it deinitializes `{}`",
                    quote! { #field }
                };

                let deinit_func_name = syn::Ident::new(
                    &format!("deinit_{}", quote! { #func_name }),
                    func_name.span()
                );
                deinit_block.extend(std::iter::once(
                    quote! {
                        #[doc = #deinit_func_doc]
                        #[inline(always)]
                        #vis fn #deinit_func_name(self) -> #partial_name<#old_generic_args> {
                            #partial_name {
                                #deinitializer
                            }
                        }
                    }
                ));
            }

            let func_doc = format! {
                " This is a FIF, it takes a `{}` and initializes `{}`",
                quote! { #ty }, quote! { #field }
            };

            let default_doc = format! {
                "and has {} default value",
                if let DefaultAttribute::None = &attr.def { "no" } else { "a" }
            };

            quote! {
                #[allow(non_camel_case_types)]
                impl <#impl_generics> #partial_name<#old_generic_args>
                #where_clause {
                    #[doc = #func_doc]
                    #[doc = #default_doc]
                    #[inline(always)]
                    #vis fn #func_name<#field: ::partial_init_core::Init<#internal_module::#field, #ty>>(self, #field: #field) -> #partial_name<#generic_args> {
                        #partial_name {
                            #initializer
                        }
                    }
                }
            }
        });
    
    (iter, has_deinit_block)
}
